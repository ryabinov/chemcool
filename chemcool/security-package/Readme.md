###Полезные ссылки:

* [Google API OAuth2](https://developers.google.com/identity/sign-in/web/people)
* [Facebook API OAuth2](https://developers.facebook.com/docs/graph-api/reference/user/)

##Настройка авторизации через соц. сети:
* Configuration
   - config-repo
     - authorization-application.yml
    
Заходим в [консоль Google API](https://console.developers.google.com/projectselector/apis/credentials?pli=1),
настраиваем авторизацию и страницу перенаправления:<br>
[http://localhost:8080/authorization-application/oauth2/callback/google].
<br><br>Так же заходим в [консоль Facebook Developers](https://developers.facebook.com/apps/), настраиваем авторизацию и 
страницу перенаправления:<br>
[http://localhost:8080/authorization-application/oauth2/callback/facebook].
<br><br>Не забываем указать у обоих Scope.
<br>Получаем **clientId** & **clientSecret**, вводим в соответствующие поля в .yml.
<br>P.S. после того как у вас все заработает, стукните в личку в телеге @ruslboss, чтобы я удалил данные из своей консоли.


##Настройка почты для отправки писем:
* Configuration
    - config-repo
        - registration-application.yml
    
Письма отправляются через почту Google, просто введите email/password от своего gmail.
<br> Перед работой, желательно открыть почту gmail в браузере, т.к гугл, бывает, блокирует учетку,
и нужно будет вводить пароль заново.


##Значение некоторых полей в БД:
Благодаря тому, что модули authorization и registration слушают топики друг друга,
их Базы данных всегда синхронизированы.
* enabled -> (boolean) true - если подтвержден Email. false - если не подтвержден.
* verification_code -> код подтверждения Email, встроен в ссылку, высылается на почту.
* reset_password_token -> код сброса пароля, встроен в ссылку, высылается на почту.
* provider -> Провайдеры - google, facebook, local(классическая регистрация).


##Принцип работы авторизации через соц. сети:
Функционал сосредоточен в модуле authorization. class OAuth2UserService.
<br>
1) Пользователь выбирает вход через соц. сеть.
2) Происходит обращение к странице авторизации в этой соц. сети, если человек еще не авторизовался там. После ввода данных, 
   если он ранее не авторизовался, происходит запрос на разрешение использования его данных.
3) Если человек отказывается, то на этом конец. Если дает согласие, то выполняется перенаправление на указанную в настройках 
   OAuth2 страницу сайта.
4) После того, как пользователь дал разрешение на использование его данных, запрашиваются нужные данные от соц. сети. 
   Проверяем, есть ли такой Email в БД, и к какому провайдеру принадлежит.
    
    **Если Email не найден в БД:**
    - Сохраняем пользователя в БД модуля авторизации (устанавливаем некоторые данные для пользователя 
      в CustomOAuth2UserService.registerNewUser), отправляем event.CREATE в топик 'registration-users-social'.
    - Модуль registration слушает топик 'registration-users-social' -> получает event.CREATE -> сохраняет event в свою БД -> 
    сохраняет юзера из payload в свою БД. 
    
    **Если email есть в БД и совпадает с провайдером, с которого авторизовались** 
    - будет произведено обновление 
     пользователя в БД и отправлен event.UPDATE в топик 'registration-users-social'.

    **Если email есть в БД и НЕ совпадает с провайдером, с которого авторизовались** 
    - покажется предупреждение, что
   пользователь уже регистрировался через другого провайдера с таким email.

5) Создается сессия с данными пользователя.


##Принцип работы классической регистрации:
Функционал сосредоточен в модуле registration.
1) Пользователь заполняет форму и отправляет запрос.
2) Присваиваем Enabled=false, создаем токен верификации Email, отправляем письмо со ссылкой активации на почту.
3) Записываем Пользователя в БД, отправляем event.CREATE в топик 'registration-users'
4) модуль authorization слушает топик 'registration-users' -> получает event -> сохраняет event в свою БД ->
   сохраняет юзера из payload в свою БД.
   >Пока пользователь не подтвердит Email, он не сможет войти на сайт.
5) Пользователь переходит по ссылке -> меняем enable на true, удаляем токен верификации email, 
   обновляем юзера в БД -> отправляем event.UPDATE в топик 'registration-users'
6) модуль authorization слушает топик 'registration-users' -> получает event.UPDATE -> сохраняет event в свою БД ->
   обновляет юзера из payload в своей БД.
7) пользователь может авторизоваться.


##Принцип работы восстановления пароля:
1) Пользователь указывает в форме Email и отправляет запрос.
2) Cоздаем токен верификации, записываем токен в БД на пользователя с тем Email, отправляем event.UPDATE в топик 'registration-users'.
3) Отправляем письмо со ссылкой активации на почту.
4) Пользователь переходит по ссылке -> ищем токен в бд, если находим -> отображаем формы для ввода пароля. если нет,
   пишем что пользователь не найден.
5) После нажатия на кнопку смены пароля, записываем новый пароль в БД, отправляем event.UPDATE в топик 'registration-users'.
6) модуль authorization соответственно слушает топик 'registration-users' и обновляет.

>После запуска фронта и микросервисов, подождите 1 минуту перед работой.